
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>PF_Pop_Inf_v2_3</title>
      <meta name="generator" content="MATLAB 7.6">
      <meta name="date" content="2008-10-16">
      <meta name="m-file" content="PF_Pop_Inf_v2_3"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#3">1) set simulation metadata</a></li>
               <li><a href="#4">2) initialize parameters</a></li>
               <li><a href="#5">3) simulate data</a></li>
               <li><a href="#6">4) plot simulation results</a></li>
               <li><a href="#7">5) estimate connection matrix directly from spikes</a></li>
               <li><a href="#8">6) pop pf preparation</a></li>
               <li><a href="#9">7) Pop inference using fast filter</a></li>
               <li><a href="#10">8)  Pop EM iteration</a></li>
               <li><a href="#11">9) plot data and inference</a></li>
            </ul>
         </div><pre class="codeinput"><span class="keyword">function</span> PF_Pop_Inf_v2_3(T)
</pre><pre class="codeinput"><span class="comment">% this script simulates Sim.Nc cells, and then infers spikes for each,</span>
<span class="comment">% assuming they are independent.</span>
<span class="comment">%</span>
<span class="comment">% 1) set simulation metadata</span>
<span class="comment">% 2) initialize parameters</span>
<span class="comment">% 3) simulate data</span>
<span class="comment">% 4) plot simulation (ie, truth)</span>
<span class="comment">% 5) estimate connection matrix from spikes</span>
<span class="comment">% 6) prep for spike inference and matrix learning</span>
<span class="comment">% 7) omega inference using fast filter</span>
<span class="comment">% 8) omega inference using particle filter</span>
<span class="comment">% 9) make pretty fig</span>
<span class="comment">%</span>
<span class="comment">% Remarks:</span>
<span class="comment">% a) some of the code is general for Sim.M spike history terms per neurons, but not all (eg, time constants)</span>
<span class="comment">% b) inference assumes all correct parameters (except those governing GLM)</span>
<span class="comment">% c) # of external stimulus dimensions is currently restricted to 1</span>
<span class="comment">%</span>
<span class="comment">% Version Updates:</span>
<span class="comment">% v2_1: put EM in loop, assume that each neuron has 1 spike history term in</span>
<span class="comment">% E-step, don't plot inference between each EM iteration</span>
<span class="comment">%</span>
<span class="comment">% v2_2: code is general enough for arbitrary # neurons.  also started</span>
<span class="comment">% writing code to estimate matrix using fast method</span>
<span class="comment">%</span>
<span class="comment">% v2_3: is now a function that takes input T for time. also only saves</span>
<span class="comment">% stuff needed for plotting, not other crap.</span>
</pre><h2>1) set simulation metadata<a name="3"></a></h2><pre class="codeinput"><span class="comment">% metaparameters to simulate data</span>
Sim.T       = T;                                    <span class="comment">% # of time steps</span>
Sim.dt      = 1/60;                                 <span class="comment">% time step size</span>
Sim.D       = 1;                                    <span class="comment">% # dimensions of external stimulus</span>
Sim.x       = ones(Sim.D,Sim.T);                    <span class="comment">% stimulus</span>
Sim.Nc      = 5;                                    <span class="comment">% # of cells</span>
</pre><pre class="codeoutput">Input argument "T" is undefined.

Error in ==&gt; PF_Pop_Inf_v2_3 at 33
Sim.T       = T;                                    % # of time steps

</pre><h2>2) initialize parameters<a name="4"></a></h2><pre class="codeinput">rate        = 5;                                    <span class="comment">% expected spike rate (assuming no spike history terms and Sim.x=1)</span>
P.k         = log(-log(1-rate*Sim.dt)/Sim.dt);      <span class="comment">% linear filter</span>
P.k         = P.k*ones(Sim.D,1);                    <span class="comment">% initialize k to the right number of dimensions</span>
P.tau_c     = 0.5;                                  <span class="comment">% calcium decay time constant (sec)</span>
P.A         = 20;                                   <span class="comment">% jumps size (\mu M)</span>
P.C_0       = 20;                                   <span class="comment">% baseline [Ca++] (\mu M)</span>
P.C_init    = P.C_0;                                <span class="comment">% initial [Ca++] (\mu M)</span>
P.sigma_c   = 1;                                    <span class="comment">% noise on</span>
P.n         = 1.0;                                  <span class="comment">% hill equation exponent</span>
P.k_d       = 200;                                  <span class="comment">% hill coefficient</span>
P.alpha     = 1;                                    <span class="comment">% F_max</span>
P.beta      = 0;                                    <span class="comment">% F_min</span>
P.gamma     = 4e-5;                                 <span class="comment">% scaled variance</span>
P.zeta      = 4*P.gamma;                            <span class="comment">% constant variance</span>
P.tau_h     = 0.05;                                  <span class="comment">% time constant</span>
P.sigma_h   = 0.01;                                 <span class="comment">% stan dev of noise</span>
<span class="comment">% P.omega     = [.1 -3; -3 .1];                   % weights</span>
<span class="comment">% if Sim.Nc&gt;2</span>
<span class="comment">%     omega = zeros(Sim.Nc);</span>
<span class="comment">%     omega(1:2,1:2)=P.omega;</span>
<span class="comment">%     P.omega = omega;</span>
<span class="comment">% end</span>
w=.5;
P.omega=diag(-1*ones(Sim.Nc,1));
P.omega(1,2)=w;
P.omega(end,end-1)=w/2;
<span class="keyword">for</span> i=2:Sim.Nc-1
    P.omega(i,i-1)=w/2;
    P.omega(i,i+1)=w;
<span class="keyword">end</span>
<span class="comment">% figure(3), clf, imagesc(P.omega), colormap(gray)</span>
</pre><h2>3) simulate data<a name="5"></a></h2><pre class="codeinput">S(1).h     = zeros(1,Sim.T);
S(1).n     = zeros(1,Sim.T);
S(1).C     = zeros(1,Sim.T);
S(1).F     = zeros(1,Sim.T);
<span class="keyword">for</span> ii=2:Sim.Nc; S(ii)=S(1); <span class="keyword">end</span>

kx      = P.k'*Sim.x;                                   <span class="comment">% external input to neuron</span>
eps_c   = P.sigma_c*sqrt(Sim.dt)*randn(Sim.Nc,Sim.T);   <span class="comment">% generate noise on calcium</span>
U_sampl = rand(Sim.Nc,Sim.T);                           <span class="comment">% generate random number to use for sampling</span>
eps_h   = repmat(P.sigma_h*sqrt(Sim.dt),Sim.Nc,Sim.T).*randn(Sim.Nc,Sim.T); <span class="comment">% generate noise on spike history</span>
eps_F   = randn(Sim.Nc,Sim.T);                          <span class="comment">% generate noise on fluorescence</span>
p       = zeros(Sim.Nc,Sim.T);                          <span class="comment">% prob of spiking for each cell at each tim</span>
y       = zeros(Sim.Nc,Sim.T);                          <span class="comment">% input to each cell at each time</span>

<span class="keyword">for</span> t=2:Sim.T                                           <span class="comment">% update states</span>
    <span class="keyword">for</span> i=1:Sim.Nc                                      <span class="comment">% loop over presynaptic cells</span>
        S(i).h(t)   = (1-Sim.dt./P.tau_h).*S(i).h(t-1) + S(i).n(t-1) + eps_h(i,t); <span class="comment">% update h terms</span>
    <span class="keyword">end</span>

    <span class="keyword">for</span> i=1:Sim.Nc                                      <span class="comment">% loop over presynaptic cells</span>
        y(i,t)      = kx(t);                            <span class="comment">% initialize input to cell</span>
        <span class="keyword">for</span> j=1:Sim.Nc                                  <span class="comment">% loop of post-synaptic cells</span>
            y(i,t)  = y(i,t)+P.omega(i,j)*S(j).h(t);    <span class="comment">% generate operand for rate function</span>
        <span class="keyword">end</span>
        p(i,t)      = 1-exp(-exp(y(i,t))*Sim.dt);       <span class="comment">% generate prob of spiking</span>
        S(i).n(t)   = U_sampl(i,t)&lt;p(i,t);              <span class="comment">% sample from bernoulli with prob p_t</span>
        S(i).C(t)   = (1-Sim.dt/P.tau_c)*S(i).C(t-1) +<span class="keyword">...</span>
            (Sim.dt/P.tau_c)*P.C_0 + P.A*S(i).n(t) + eps_c(i,t); <span class="comment">%update calcium</span>
        s           = Hill_v1(P,S(i).C(t));             <span class="comment">% compute saturated calcium</span>
        S(i).F(t)   = (P.alpha*s+P.beta)+sqrt(P.gamma*s+P.zeta).*eps_F(i,t); <span class="comment">% update fluorescence</span>
        <span class="keyword">if</span> S(i).F(t)&lt;=0; S(i).F(t) = eps; <span class="keyword">end</span>           <span class="comment">% keep fluorescence positive</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>4) plot simulation results<a name="6"></a></h2><pre class="codeinput"><span class="comment">% tt  = 500;</span>
<span class="comment">% col = [1 0 0; 0 0 1; 0 0.5 0; 1 0.5 0; 1 0 1];          % define colors for mean</span>
<span class="comment">% figure(1), clf</span>
<span class="comment">% for i=1%:Sim.Nc</span>
<span class="comment">%     h1=subplot(311); hold on, plot(z1(S(i).F(tt:2*tt))+1,'Color',col(i,:)); stem(S(i).n(tt:2*tt),'Color',col(i,:)), axis('tight'), ylabel('F')</span>
<span class="comment">%     h2=subplot(312); hold on, plot(y(i,(tt:2*tt)),'Color',col(i,:)), axis('tight'), ylabel('y') %stem(S(i).n,'Color',col(i,:)),</span>
<span class="comment">%     h3=subplot(313); hold on, plot(p(i,(tt:2*tt)),'Color',col(i,:)), axis('tight'), ylabel('p')</span>
<span class="comment">% end</span>
<span class="comment">% linkaxes([h1 h2 h3],'x')</span>
<span class="comment">% legend('1','2')</span>
<span class="comment">% for i=1:Sim.Nc, disp(sum(S(i).n)); end</span>
</pre><h2>5) estimate connection matrix directly from spikes<a name="7"></a></h2><pre class="codeinput">Sim.M       = 1;                                    <span class="comment">% # spike history terms per neuron (fixed at one for this version of code)</span>
Sim.n_params= 1;                                    <span class="comment">% if 1, estimate k</span>
Sim.h_params= 1;                                    <span class="comment">% if 1, estimate omega (self-coupling)</span>
Sim.F_params= 0;                                    <span class="comment">% if 1, estimate observation parameters</span>
Sim.C_params= 0;                                    <span class="comment">% whether to compute</span>
Sim.StimDim = Sim.Nc;                               <span class="comment">% set external stim dimesions to # cells</span>
Tim         = Sim;                                  <span class="comment">% Tim is Sim for this estimation</span>
Tim.N       = 1;                                    <span class="comment">% # of particles</span>
<span class="keyword">for</span> i=1:Sim.Nc
    h=zeros(Sim.Nc-1,Sim.T);
    Pre=1:Sim.Nc;                                   <span class="comment">% generate list of presynaptic neurons</span>
    Pre(Pre==i)=[];                                 <span class="comment">% remove self</span>
    k=0;                                            <span class="comment">% counter of dimension</span>
    <span class="keyword">for</span> j=Pre                                       <span class="comment">% loop thru all presynaptic neurons</span>
        k=k+1;                                      <span class="comment">% generate input to neuron based on posterior mean spike train from neuron j</span>
        h(k,:) = S(j).h;
    <span class="keyword">end</span>
    Tim.x       = [Sim.x; h];                       <span class="comment">% append input from other neurons onto external stimulus</span>
    E           = P;
    E.omega     = E.omega(i,i);                     <span class="comment">% initialize self-coupling term</span>
    E.k         = E.k*ones(Sim.Nc,1);               <span class="comment">% initialize external stim and cross-coupling terms</span>
    S(i).w_b    = ones(1,Sim.T);
    Enew2{i}    = GOOPSI_Mstep_v1_0(Tim,S(i),0,E,S(i).F);
<span class="keyword">end</span>

Phat{1}.omega = GetMatrix(Sim.Nc,Enew2);

<span class="comment">% Phat{1}.omega=zeros(Sim.Nc);</span>
<span class="comment">% for i=1:Sim.Nc</span>
<span class="comment">%     Phat{1}.omega(i,i)=Enew2{i}.omega;</span>
<span class="comment">%     Pre=1:Sim.Nc;                                   % generate list of presynaptic neurons</span>
<span class="comment">%     Pre(Pre==i)=[];                                 % remove self</span>
<span class="comment">%     k=0;                                            % counter of dimension</span>
<span class="comment">%     for j=Pre</span>
<span class="comment">%         k=k+1;                                      % generate input to neuron based on posterior mean spike train from neuron j</span>
<span class="comment">%         Phat{1}.omega(i,j)=Enew2{i}.k(k+1);</span>
<span class="comment">%     end</span>
<span class="comment">% end</span>
<span class="comment">% [P.omega; round(Phat{1}.omega*10)/10]</span>
<span class="comment">%</span>
<span class="comment">% figure(3), clf,</span>
<span class="comment">% clims(1)=min(min(P.omega(:)),min(Phat{1}.omega(:)));</span>
<span class="comment">% clims(2)=max(max(P.omega(:)),max(Phat{1}.omega(:)));</span>
<span class="comment">% subplot(121), imagesc(P.omega,clims), colormap(gray), %colorbar</span>
<span class="comment">% subplot(122), imagesc(Phat{1}.omega,clims), %colorbar</span>
</pre><h2>6) pop pf preparation<a name="8"></a></h2><pre class="codeinput"><span class="comment">% metaparameters necessary to run smc-em code</span>
Sim.N       = 99;                                   <span class="comment">% # of particles</span>
Sim.Mstep   = 1;                                    <span class="comment">% whether to estimate parameters</span>
Sim.pf      = 1;                                    <span class="comment">% if 1, then conditional sampler, if 0, then prior sampler</span>
Sim.freq    = 1;                                    <span class="comment">% # time steps per observation (d in BJ08)</span>
Sim.T_o     = Sim.T/Sim.freq;                       <span class="comment">% # of observable time steps</span>
Sim.M       = 1;                                    <span class="comment">% # of spike history terms per neuron</span>
Sim.Mstep   = 0;                                    <span class="comment">% whether to estimate parameters</span>
Sim.ptiles  = 1;                                    <span class="comment">% generate percentiles</span>

<span class="comment">% initialize stuff for each cell</span>
Tim         = Sim;                                  <span class="comment">% copy Sim structure for input to Mstep function</span>
E           = P;
E.omega     = E.omega(i,i);                         <span class="comment">% initialize self-coupling term</span>
E.k         = E.k*ones(Sim.StimDim,1);              <span class="comment">% initialize external stim and cross-coupling terms</span>
<span class="keyword">for</span> i=1:Sim.Nc,
    I{i}.M.nbar = zeros(1,Sim.T);                   <span class="comment">% initialize spike trains</span>
    I{i}.P      = E;                                <span class="comment">% initialize parameters</span>
<span class="keyword">end</span>
</pre><h2>7) Pop inference using fast filter<a name="9"></a></h2><pre class="codeinput"><span class="comment">% E.tau       = E.tau_c;                                  % calcium decay time constant (sec)</span>
<span class="comment">% E.sig       = E.sigma_c;                                    % noise on</span>
<span class="comment">% E.lam       = Sim.T/(rate*E.A)*Sim.dt;              % expected jump size ber time bin</span>
<span class="comment">% Sim.Plot    = 1;</span>
<span class="comment">% Sim.MaxIter = 10;                                   % max number of EM iterations</span>
<span class="comment">%</span>
<span class="comment">% for i=1:Sim.Nc,                                     % initialize estimate of spike trains</span>
<span class="comment">%     [Fn{i} FP{i}]       = FOOPSI_v1_9(S(i).F',E,Sim);</span>
<span class="comment">% end</span>
<span class="comment">%</span>
<span class="comment">% for i=1:Sim.Nc</span>
<span class="comment">%</span>
<span class="comment">%     % append external stimulus for neuron 'i' with spike histories from other cells</span>
<span class="comment">%     h = zeros(Sim.Nc-1,Sim.T);                  % we append this to x to generate input into neuron from other neurons</span>
<span class="comment">%     Pre=1:Sim.Nc;                               % generate list of presynaptic neurons</span>
<span class="comment">%     Pre(Pre==i)=[];                             % remove self</span>
<span class="comment">%     k=0;                                        % counter of dimension</span>
<span class="comment">%     for j=Pre                                   % loop thru all presynaptic neurons</span>
<span class="comment">%         k=k+1;                                  % generate input to neuron based on posterior mean spike train from neuron j</span>
<span class="comment">%         h(k,:) = filter(1,[1 -(1-Sim.dt/P.tau_h)],Fn{j}/max(Fn{j}));</span>
<span class="comment">%     end</span>
<span class="comment">%     Tim.x   = [Sim.x; h];                         % append input from other neurons onto external stimulus</span>
<span class="comment">%     Tim.N   = 1;</span>
<span class="comment">%     T.w_b   = ones(1,Sim.T);</span>
<span class="comment">%     T.n     = Fn{i};</span>
<span class="comment">%     T.C     = filter(1,[1 -(1-Sim.dt/FP{i}.tau)],Fn{j}/max(Fn{j}));</span>
<span class="comment">%     T.h     = filter(1,[1 -(1-Sim.dt/E.tau_h)],Fn{j}/max(Fn{j}));;</span>
<span class="comment">%     FP{i}   = GOOPSI_Mstep_v1_0(Tim,T,0,II{i}.P,S(i).F);</span>
<span class="comment">% end</span>
<span class="comment">% PlotPop_v1_0(Sim,FE,P.omega,Phat{1}.omega)</span>
</pre><h2>8)  Pop EM iteration<a name="10"></a></h2><pre class="codeinput"><span class="keyword">for</span> tr=1:3

    <span class="comment">% for each neuron, infer spike train conditioned on previous EM</span>
    <span class="comment">% iterations spike history terms</span>
    <span class="keyword">for</span> i=1:Sim.Nc,                                 <span class="comment">% infer spikes for each neuron</span>

        <span class="comment">% append external stimulus for neuron 'i' with spike histories from other cells</span>
        h = zeros(Sim.Nc-1,Sim.T);                  <span class="comment">% we append this to x to generate input into neuron from other neurons</span>
        Pre=1:Sim.Nc;                               <span class="comment">% generate list of presynaptic neurons</span>
        Pre(Pre==i)=[];                             <span class="comment">% remove self</span>
        k=0;                                        <span class="comment">% counter of dimension</span>
        <span class="keyword">for</span> j=Pre                                   <span class="comment">% loop thru all presynaptic neurons</span>
            k=k+1;                                  <span class="comment">% generate input to neuron based on posterior mean spike train from neuron j</span>
            h(k,:) = filter(1,[1 -(1-Sim.dt/P.tau_h)],I{j}.M.nbar);
        <span class="keyword">end</span>
        Tim.x = [Sim.x; h];                         <span class="comment">% append input from other neurons onto external stimulus</span>

        <span class="comment">% infer spike train for neuron 'i'</span>
        [II{i}.S II{i}.M II{i}.P] = GOOPSI_main_v3_0(S(i).F,I{i}.P,Tim);
    <span class="keyword">end</span>

    <span class="comment">% set inference for each neuron to the newly updated inference</span>
    <span class="keyword">for</span> i=1:Sim.Nc, I{i}.S = II{i}.S; I{i}.M = II{i}.M; <span class="keyword">end</span>

    <span class="comment">% given new inference for each neuron, update parameters</span>
    <span class="keyword">for</span> i=1:Sim.Nc

        <span class="comment">% append external stimulus for neuron 'i' with spike histories from other cells</span>
        h = zeros(Sim.Nc-1,Sim.T);                  <span class="comment">% we append this to x to generate input into neuron from other neurons</span>
        Pre=1:Sim.Nc;                               <span class="comment">% generate list of presynaptic neurons</span>
        Pre(Pre==i)=[];                             <span class="comment">% remove self</span>
        k=0;                                        <span class="comment">% counter of dimension</span>
        <span class="keyword">for</span> j=Pre                                   <span class="comment">% loop thru all presynaptic neurons</span>
            k=k+1;                                  <span class="comment">% generate input to neuron based on posterior mean spike train from neuron j</span>
            h(k,:) = filter(1,[1 -(1-Sim.dt/P.tau_h)],I{j}.M.nbar);
        <span class="keyword">end</span>
        Tim.x = [Sim.x; h];                         <span class="comment">% append input from other neurons onto external stimulus</span>

        I{i}.P  = GOOPSI_Mstep_v1_0(Tim,I{i}.S,0,II{i}.P,S(i).F);
        EE{i}    = I{i}.P;
    <span class="keyword">end</span>
    Phat{2}.omega = GetMatrix(Sim.Nc,Enew2);
    save([<span class="string">'SimConnector'</span>, num2str(Sim.T), num2str(tr)],<span class="string">'Phat'</span>,<span class="string">'S'</span>,<span class="string">'Sim'</span>,<span class="string">'P'</span>)
<span class="comment">%     PlotPop_v1_0(Sim,EE,P.omega,Phat{1}.omega)</span>
<span class="comment">%     save('SimConnector')</span>
<span class="comment">%     Fs=tr*1024; ts=0:1/Fs:1; sound(sin(2*pi*ts*200)),</span>
<span class="keyword">end</span>
</pre><h2>9) plot data and inference<a name="11"></a></h2><pre class="codeinput">fig=figure(5); clf,
col = [1 0 0; 0 0 1; 0 0.5 0; 1 0.5 0; 1 0 1];          <span class="comment">% define colors for mean</span>

<span class="comment">% Phat.omega=zeros(Sim.Nc);</span>
<span class="comment">% for i=1:Sim.Nc</span>
<span class="comment">%     Phat.omega(i,i)=I{i}.P.omega;</span>
<span class="comment">%     Pre=1:Sim.Nc;                                   % generate list of presynaptic neurons</span>
<span class="comment">%     Pre(Pre==i)=[];                                 % remove self</span>
<span class="comment">%     k=0;                                            % counter of dimension</span>
<span class="comment">%     for j=Pre</span>
<span class="comment">%         k=k+1;                                      % generate input to neuron based on posterior mean spike train from neuron j</span>
<span class="comment">%         Phat.omega(i,j)=I{i}.P.k(k+1);</span>
<span class="comment">%     end</span>
<span class="comment">% end</span>

tt=500;
subplot(2,3,[1 2 3]), hold <span class="string">on</span>
<span class="keyword">for</span> i=1:3
    plot(z1(S(i).F(tt:2*tt))+1,<span class="string">'Color'</span>,col(i,:));
<span class="keyword">end</span>
axis(<span class="string">'tight'</span>),
xticks  = 0:round(tt/5):tt;               <span class="comment">% XTick positions</span>
set(gca,<span class="string">'YTick'</span>,[],<span class="string">'YTickLabel'</span>,[])
set(gca,<span class="string">'XTick'</span>,xticks,<span class="string">'XTickLabel'</span>,xticks*Sim.dt)
ylabel(<span class="string">'Fluorescence'</span>)
xlabel(<span class="string">'Time (sec)'</span>)

clims(1)=min([P.omega(:)' Phat{1}.omega(:)' Phat{2}.omega(:)']);
clims(2)=max([P.omega(:)' Phat{1}.omega(:)' Phat{2}.omega(:)']);
subplot(234), imagesc(P.omega,clims), colormap(gray),
set(gca,<span class="string">'XTick'</span>,[1:Sim.Nc],<span class="string">'YTick'</span>,[1:Sim.Nc]) <span class="comment">%colorbar</span>
title(<span class="string">'True matrix'</span>)
ylabel(<span class="string">'Presynaptic'</span>), xlabel(<span class="string">'Postsynaptic'</span>)

subplot(235), imagesc(Phat{2}.omega,clims), <span class="comment">%colorbar</span>
set(gca,<span class="string">'XTick'</span>,[1:Sim.Nc],<span class="string">'YTick'</span>,[1:Sim.Nc]) <span class="comment">%colorbar</span>
title(<span class="string">'Matrix from spikes'</span>)
<span class="comment">% ylabel('Presynaptic'), xlabel('Postsynaptic')</span>

subplot(236), imagesc(Phat{1}.omega,clims), <span class="comment">%colorbar</span>
set(gca,<span class="string">'XTick'</span>,[1:Sim.Nc],<span class="string">'YTick'</span>,[1:Sim.Nc]) <span class="comment">%colorbar</span>
title(<span class="string">'Matrix from fluorescence'</span>)
<span class="comment">% ylabel('Presynaptic'), xlabel('Postsynaptic')</span>

<span class="comment">% print fig</span>
wh=[7 5];   <span class="comment">%width and height</span>
set(fig,<span class="string">'PaperPosition'</span>,[0 11-wh(2) wh]);
print(<span class="string">'-depsc'</span>,<span class="string">'SimConnector'</span>)
print(<span class="string">'-dpdf'</span>,<span class="string">'SimConnector'</span>)
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> omega = GetMatrix(Nc,P)

omega=zeros(Nc);
<span class="keyword">for</span> i=1:Nc
    omega(i,i)=P{i}.omega;
    Pre=1:Nc;                                       <span class="comment">% generate list of presynaptic neurons</span>
    Pre(Pre==i)=[];                                 <span class="comment">% remove self</span>
    k=0;                                            <span class="comment">% counter of dimension</span>
    <span class="keyword">for</span> j=Pre
        k=k+1;                                      <span class="comment">% generate input to neuron based on posterior mean spike train from neuron j</span>
        omega(i,j)=P{i}.k(k+1);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">end</span>
</pre><pre class="codeoutput">WDEavRCxrA000030000</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.6<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
function PF_Pop_Inf_v2_3(T)
% this script simulates Sim.Nc cells, and then infers spikes for each,
% assuming they are independent.
%
% 1) set simulation metadata
% 2) initialize parameters
% 3) simulate data
% 4) plot simulation (ie, truth)
% 5) estimate connection matrix from spikes
% 6) prep for spike inference and matrix learning
% 7) omega inference using fast filter
% 8) omega inference using particle filter
% 9) make pretty fig
%
% Remarks:
% a) some of the code is general for Sim.M spike history terms per neurons, but not all (eg, time constants)
% b) inference assumes all correct parameters (except those governing GLM)
% c) # of external stimulus dimensions is currently restricted to 1
%
% Version Updates:
% v2_1: put EM in loop, assume that each neuron has 1 spike history term in
% E-step, don't plot inference between each EM iteration
%
% v2_2: code is general enough for arbitrary # neurons.  also started
% writing code to estimate matrix using fast method
%
% v2_3: is now a function that takes input T for time. also only saves
% stuff needed for plotting, not other crap.

%% 1) set simulation metadata

% metaparameters to simulate data
Sim.T       = T;                                    % # of time steps
Sim.dt      = 1/60;                                 % time step size
Sim.D       = 1;                                    % # dimensions of external stimulus
Sim.x       = ones(Sim.D,Sim.T);                    % stimulus
Sim.Nc      = 5;                                    % # of cells

%% 2) initialize parameters

rate        = 5;                                    % expected spike rate (assuming no spike history terms and Sim.x=1)
P.k         = log(-log(1-rate*Sim.dt)/Sim.dt);      % linear filter
P.k         = P.k*ones(Sim.D,1);                    % initialize k to the right number of dimensions
P.tau_c     = 0.5;                                  % calcium decay time constant (sec)
P.A         = 20;                                   % jumps size (\mu M)
P.C_0       = 20;                                   % baseline [Ca++] (\mu M)
P.C_init    = P.C_0;                                % initial [Ca++] (\mu M)
P.sigma_c   = 1;                                    % noise on
P.n         = 1.0;                                  % hill equation exponent
P.k_d       = 200;                                  % hill coefficient
P.alpha     = 1;                                    % F_max
P.beta      = 0;                                    % F_min
P.gamma     = 4e-5;                                 % scaled variance
P.zeta      = 4*P.gamma;                            % constant variance
P.tau_h     = 0.05;                                  % time constant
P.sigma_h   = 0.01;                                 % stan dev of noise
% P.omega     = [.1 -3; -3 .1];                   % weights
% if Sim.Nc>2
%     omega = zeros(Sim.Nc);
%     omega(1:2,1:2)=P.omega;
%     P.omega = omega;
% end
w=.5;
P.omega=diag(-1*ones(Sim.Nc,1));
P.omega(1,2)=w;
P.omega(end,end-1)=w/2;
for i=2:Sim.Nc-1
    P.omega(i,i-1)=w/2;
    P.omega(i,i+1)=w;
end
% figure(3), clf, imagesc(P.omega), colormap(gray)

%% 3) simulate data

S(1).h     = zeros(1,Sim.T);
S(1).n     = zeros(1,Sim.T);
S(1).C     = zeros(1,Sim.T);
S(1).F     = zeros(1,Sim.T);
for ii=2:Sim.Nc; S(ii)=S(1); end

kx      = P.k'*Sim.x;                                   % external input to neuron
eps_c   = P.sigma_c*sqrt(Sim.dt)*randn(Sim.Nc,Sim.T);   % generate noise on calcium
U_sampl = rand(Sim.Nc,Sim.T);                           % generate random number to use for sampling
eps_h   = repmat(P.sigma_h*sqrt(Sim.dt),Sim.Nc,Sim.T).*randn(Sim.Nc,Sim.T); % generate noise on spike history
eps_F   = randn(Sim.Nc,Sim.T);                          % generate noise on fluorescence
p       = zeros(Sim.Nc,Sim.T);                          % prob of spiking for each cell at each tim
y       = zeros(Sim.Nc,Sim.T);                          % input to each cell at each time

for t=2:Sim.T                                           % update states
    for i=1:Sim.Nc                                      % loop over presynaptic cells
        S(i).h(t)   = (1-Sim.dt./P.tau_h).*S(i).h(t-1) + S(i).n(t-1) + eps_h(i,t); % update h terms
    end

    for i=1:Sim.Nc                                      % loop over presynaptic cells
        y(i,t)      = kx(t);                            % initialize input to cell
        for j=1:Sim.Nc                                  % loop of post-synaptic cells
            y(i,t)  = y(i,t)+P.omega(i,j)*S(j).h(t);    % generate operand for rate function
        end
        p(i,t)      = 1-exp(-exp(y(i,t))*Sim.dt);       % generate prob of spiking
        S(i).n(t)   = U_sampl(i,t)<p(i,t);              % sample from bernoulli with prob p_t
        S(i).C(t)   = (1-Sim.dt/P.tau_c)*S(i).C(t-1) +...
            (Sim.dt/P.tau_c)*P.C_0 + P.A*S(i).n(t) + eps_c(i,t); %update calcium
        s           = Hill_v1(P,S(i).C(t));             % compute saturated calcium
        S(i).F(t)   = (P.alpha*s+P.beta)+sqrt(P.gamma*s+P.zeta).*eps_F(i,t); % update fluorescence
        if S(i).F(t)<=0; S(i).F(t) = eps; end           % keep fluorescence positive
    end
end

%% 4) plot simulation results

% tt  = 500;
% col = [1 0 0; 0 0 1; 0 0.5 0; 1 0.5 0; 1 0 1];          % define colors for mean
% figure(1), clf
% for i=1%:Sim.Nc
%     h1=subplot(311); hold on, plot(z1(S(i).F(tt:2*tt))+1,'Color',col(i,:)); stem(S(i).n(tt:2*tt),'Color',col(i,:)), axis('tight'), ylabel('F')
%     h2=subplot(312); hold on, plot(y(i,(tt:2*tt)),'Color',col(i,:)), axis('tight'), ylabel('y') %stem(S(i).n,'Color',col(i,:)),
%     h3=subplot(313); hold on, plot(p(i,(tt:2*tt)),'Color',col(i,:)), axis('tight'), ylabel('p')
% end
% linkaxes([h1 h2 h3],'x')
% legend('1','2')
% for i=1:Sim.Nc, disp(sum(S(i).n)); end

%% 5) estimate connection matrix directly from spikes

Sim.M       = 1;                                    % # spike history terms per neuron (fixed at one for this version of code)
Sim.n_params= 1;                                    % if 1, estimate k
Sim.h_params= 1;                                    % if 1, estimate omega (self-coupling)
Sim.F_params= 0;                                    % if 1, estimate observation parameters
Sim.C_params= 0;                                    % whether to compute
Sim.StimDim = Sim.Nc;                               % set external stim dimesions to # cells
Tim         = Sim;                                  % Tim is Sim for this estimation
Tim.N       = 1;                                    % # of particles
for i=1:Sim.Nc
    h=zeros(Sim.Nc-1,Sim.T);
    Pre=1:Sim.Nc;                                   % generate list of presynaptic neurons
    Pre(Pre==i)=[];                                 % remove self
    k=0;                                            % counter of dimension
    for j=Pre                                       % loop thru all presynaptic neurons
        k=k+1;                                      % generate input to neuron based on posterior mean spike train from neuron j
        h(k,:) = S(j).h;
    end
    Tim.x       = [Sim.x; h];                       % append input from other neurons onto external stimulus
    E           = P;
    E.omega     = E.omega(i,i);                     % initialize self-coupling term
    E.k         = E.k*ones(Sim.Nc,1);               % initialize external stim and cross-coupling terms
    S(i).w_b    = ones(1,Sim.T);
    Enew2{i}    = GOOPSI_Mstep_v1_0(Tim,S(i),0,E,S(i).F);
end

Phat{1}.omega = GetMatrix(Sim.Nc,Enew2);

% Phat{1}.omega=zeros(Sim.Nc);
% for i=1:Sim.Nc
%     Phat{1}.omega(i,i)=Enew2{i}.omega;
%     Pre=1:Sim.Nc;                                   % generate list of presynaptic neurons
%     Pre(Pre==i)=[];                                 % remove self
%     k=0;                                            % counter of dimension
%     for j=Pre
%         k=k+1;                                      % generate input to neuron based on posterior mean spike train from neuron j
%         Phat{1}.omega(i,j)=Enew2{i}.k(k+1);
%     end
% end
% [P.omega; round(Phat{1}.omega*10)/10]
%
% figure(3), clf,
% clims(1)=min(min(P.omega(:)),min(Phat{1}.omega(:)));
% clims(2)=max(max(P.omega(:)),max(Phat{1}.omega(:)));
% subplot(121), imagesc(P.omega,clims), colormap(gray), %colorbar
% subplot(122), imagesc(Phat{1}.omega,clims), %colorbar

%% 6) pop pf preparation

% metaparameters necessary to run smc-em code
Sim.N       = 99;                                   % # of particles
Sim.Mstep   = 1;                                    % whether to estimate parameters
Sim.pf      = 1;                                    % if 1, then conditional sampler, if 0, then prior sampler
Sim.freq    = 1;                                    % # time steps per observation (d in BJ08)
Sim.T_o     = Sim.T/Sim.freq;                       % # of observable time steps
Sim.M       = 1;                                    % # of spike history terms per neuron
Sim.Mstep   = 0;                                    % whether to estimate parameters
Sim.ptiles  = 1;                                    % generate percentiles

% initialize stuff for each cell
Tim         = Sim;                                  % copy Sim structure for input to Mstep function
E           = P;
E.omega     = E.omega(i,i);                         % initialize self-coupling term
E.k         = E.k*ones(Sim.StimDim,1);              % initialize external stim and cross-coupling terms
for i=1:Sim.Nc,
    I{i}.M.nbar = zeros(1,Sim.T);                   % initialize spike trains
    I{i}.P      = E;                                % initialize parameters
end

%% 7) Pop inference using fast filter

% E.tau       = E.tau_c;                                  % calcium decay time constant (sec)
% E.sig       = E.sigma_c;                                    % noise on
% E.lam       = Sim.T/(rate*E.A)*Sim.dt;              % expected jump size ber time bin
% Sim.Plot    = 1;
% Sim.MaxIter = 10;                                   % max number of EM iterations
%
% for i=1:Sim.Nc,                                     % initialize estimate of spike trains
%     [Fn{i} FP{i}]       = FOOPSI_v1_9(S(i).F',E,Sim);
% end
%
% for i=1:Sim.Nc
%
%     % append external stimulus for neuron 'i' with spike histories from other cells
%     h = zeros(Sim.Nc-1,Sim.T);                  % we append this to x to generate input into neuron from other neurons
%     Pre=1:Sim.Nc;                               % generate list of presynaptic neurons
%     Pre(Pre==i)=[];                             % remove self
%     k=0;                                        % counter of dimension
%     for j=Pre                                   % loop thru all presynaptic neurons
%         k=k+1;                                  % generate input to neuron based on posterior mean spike train from neuron j
%         h(k,:) = filter(1,[1 -(1-Sim.dt/P.tau_h)],Fn{j}/max(Fn{j}));
%     end
%     Tim.x   = [Sim.x; h];                         % append input from other neurons onto external stimulus
%     Tim.N   = 1;
%     T.w_b   = ones(1,Sim.T);
%     T.n     = Fn{i};
%     T.C     = filter(1,[1 -(1-Sim.dt/FP{i}.tau)],Fn{j}/max(Fn{j}));
%     T.h     = filter(1,[1 -(1-Sim.dt/E.tau_h)],Fn{j}/max(Fn{j}));;
%     FP{i}   = GOOPSI_Mstep_v1_0(Tim,T,0,II{i}.P,S(i).F);
% end
% PlotPop_v1_0(Sim,FE,P.omega,Phat{1}.omega)

%% 8)  Pop EM iteration

for tr=1:3

    % for each neuron, infer spike train conditioned on previous EM
    % iterations spike history terms
    for i=1:Sim.Nc,                                 % infer spikes for each neuron

        % append external stimulus for neuron 'i' with spike histories from other cells
        h = zeros(Sim.Nc-1,Sim.T);                  % we append this to x to generate input into neuron from other neurons
        Pre=1:Sim.Nc;                               % generate list of presynaptic neurons
        Pre(Pre==i)=[];                             % remove self
        k=0;                                        % counter of dimension
        for j=Pre                                   % loop thru all presynaptic neurons
            k=k+1;                                  % generate input to neuron based on posterior mean spike train from neuron j
            h(k,:) = filter(1,[1 -(1-Sim.dt/P.tau_h)],I{j}.M.nbar);
        end
        Tim.x = [Sim.x; h];                         % append input from other neurons onto external stimulus

        % infer spike train for neuron 'i'
        [II{i}.S II{i}.M II{i}.P] = GOOPSI_main_v3_0(S(i).F,I{i}.P,Tim);
    end

    % set inference for each neuron to the newly updated inference
    for i=1:Sim.Nc, I{i}.S = II{i}.S; I{i}.M = II{i}.M; end

    % given new inference for each neuron, update parameters
    for i=1:Sim.Nc

        % append external stimulus for neuron 'i' with spike histories from other cells
        h = zeros(Sim.Nc-1,Sim.T);                  % we append this to x to generate input into neuron from other neurons
        Pre=1:Sim.Nc;                               % generate list of presynaptic neurons
        Pre(Pre==i)=[];                             % remove self
        k=0;                                        % counter of dimension
        for j=Pre                                   % loop thru all presynaptic neurons
            k=k+1;                                  % generate input to neuron based on posterior mean spike train from neuron j
            h(k,:) = filter(1,[1 -(1-Sim.dt/P.tau_h)],I{j}.M.nbar);
        end
        Tim.x = [Sim.x; h];                         % append input from other neurons onto external stimulus

        I{i}.P  = GOOPSI_Mstep_v1_0(Tim,I{i}.S,0,II{i}.P,S(i).F);
        EE{i}    = I{i}.P;
    end
    Phat{2}.omega = GetMatrix(Sim.Nc,Enew2);
    save(['SimConnector', num2str(Sim.T), num2str(tr)],'Phat','S','Sim','P')
%     PlotPop_v1_0(Sim,EE,P.omega,Phat{1}.omega)
%     save('SimConnector')
%     Fs=tr*1024; ts=0:1/Fs:1; sound(sin(2*pi*ts*200)),
end

%% 9) plot data and inference

fig=figure(5); clf,
col = [1 0 0; 0 0 1; 0 0.5 0; 1 0.5 0; 1 0 1];          % define colors for mean

% Phat.omega=zeros(Sim.Nc);
% for i=1:Sim.Nc
%     Phat.omega(i,i)=I{i}.P.omega;
%     Pre=1:Sim.Nc;                                   % generate list of presynaptic neurons
%     Pre(Pre==i)=[];                                 % remove self
%     k=0;                                            % counter of dimension
%     for j=Pre
%         k=k+1;                                      % generate input to neuron based on posterior mean spike train from neuron j
%         Phat.omega(i,j)=I{i}.P.k(k+1);
%     end
% end

tt=500;
subplot(2,3,[1 2 3]), hold on
for i=1:3
    plot(z1(S(i).F(tt:2*tt))+1,'Color',col(i,:));
end
axis('tight'),
xticks  = 0:round(tt/5):tt;               % XTick positions
set(gca,'YTick',[],'YTickLabel',[])
set(gca,'XTick',xticks,'XTickLabel',xticks*Sim.dt)
ylabel('Fluorescence')
xlabel('Time (sec)')

clims(1)=min([P.omega(:)' Phat{1}.omega(:)' Phat{2}.omega(:)']);
clims(2)=max([P.omega(:)' Phat{1}.omega(:)' Phat{2}.omega(:)']);
subplot(234), imagesc(P.omega,clims), colormap(gray),
set(gca,'XTick',[1:Sim.Nc],'YTick',[1:Sim.Nc]) %colorbar
title('True matrix')
ylabel('Presynaptic'), xlabel('Postsynaptic')

subplot(235), imagesc(Phat{2}.omega,clims), %colorbar
set(gca,'XTick',[1:Sim.Nc],'YTick',[1:Sim.Nc]) %colorbar
title('Matrix from spikes')
% ylabel('Presynaptic'), xlabel('Postsynaptic')

subplot(236), imagesc(Phat{1}.omega,clims), %colorbar
set(gca,'XTick',[1:Sim.Nc],'YTick',[1:Sim.Nc]) %colorbar
title('Matrix from fluorescence')
% ylabel('Presynaptic'), xlabel('Postsynaptic')

% print fig
wh=[7 5];   %width and height
set(fig,'PaperPosition',[0 11-wh(2) wh]);
print('-depsc','SimConnector')
print('-dpdf','SimConnector')

end

function omega = GetMatrix(Nc,P)

omega=zeros(Nc);
for i=1:Nc
    omega(i,i)=P{i}.omega;
    Pre=1:Nc;                                       % generate list of presynaptic neurons
    Pre(Pre==i)=[];                                 % remove self
    k=0;                                            % counter of dimension
    for j=Pre
        k=k+1;                                      % generate input to neuron based on posterior mean spike train from neuron j
        omega(i,j)=P{i}.k(k+1);
    end
end

end
##### SOURCE END #####
-->
   </body>
</html>